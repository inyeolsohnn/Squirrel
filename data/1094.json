{
  "id": 1094,
  "url": "www.dofactory.com/topic/1094/context-pattern.aspx",
  "title": "Context Pattern?",
  "ques": "Hi\r\n\r\nI\u0027m curious if there is a pattern that allows an object to change behavior based on context. I have looked at the State pattern, but would like to explain what i\u0027m trying to do and see if there is maybe not a better way of achiving the same.\r\n\r\nI am creating a webpage that loads menu items in a div on a page dynamically based on the context of the div. Each menu item is an object that I have created. Certain menu items are reused across different pages (example \u0027add new\u0027) , but should behave differently on different divs.\r\n\r\nFor example:\r\n\r\nI have an Abstract Employee class, and then Director Concrete Class, Manager Concrete Class ect.\r\nI also have an Abstract MenuItem Class, and then AddNewMenuItem Concrete Class, RemoveMenuItem Concrete Class.\r\n\r\nBoth Concrete Employee classes loads AddNewMenuItem classes, but when the AddNewMenuItem is clicked, it should add a New Director or add a New Manager, based on the div it was loaded in.\r\n\r\nWhat would be the best way to accomplish this?\r\n",
  "answers": [
    {
      "ansID": 1142,
      "ans": "I am not quite sure whether I understand your setup, but I get a sense it is a bit over-architected.\r\n\r\nWhy not give the base class of the Context (the Employee, Director, Manager) a virtual CreateMenus method and let each derived type implement this. Or, if you don\u0027t want to pollute the Context objects, build a static MenuFactory class with a Create method. Pass in the Context (in the Create method) and out comes a context-sentive list of menu items. \r\n\r\n\r\n"
    },
    {
      "ansID": 1143,
      "ans": "Hi Ian, Thank you for replying\r\nThat is exactly what i am doing, I have a menuFactory that returns a list of context-sensitive menu items, the problem is still letting each menu item do something differently when clicked, based on the context.\r\nFor example\r\nLoading an Employee would use the menuFactory to Load menu items ( \u0027Add \u0027, \u0027Remove \u0027, \u0027Refresh \u0027)\r\nLoading a Director would use the menuFactory to Load menu items ( \u0027Add \u0027,  \u0027Remove \u0027,  \u0027Refresh \u0027,  \u0027Pay \u0027)\r\nLoading a Manager would use the menuFactory to load menu items ( \u0027Add \u0027,  \u0027Remove \u0027,  \u0027Refresh \u0027,  \u0027Manage \u0027)\r\nAs you can see the menu items  \u0027Add \u0027,  \u0027Remove \u0027 and  \u0027Refresh \u0027 is common throughout all concrete classes.\r\nYet when I click on  \u0027Add \u0027, it needs to add an entity based on the concrete class\r\nEmployee\u0027s Add item should add an employee\r\nDirector\u0027s add item should add a director \r\nManager\u0027s add item should add a manager\r\nSo the challange i\u0027m facing is making the AddMenuItem object, behave differently, based on context.\r\n"
    },
    {
      "ansID": 1156,
      "ans": "you can do it like this:\r\nabstract a inerface contains all the actions in menus.\r\nthen create concrete class(Employee\u0027s /Director\u0027s and so on) implement this interface.\r\ncreate a controller class,it has a interface container that could save the concrete class who implement the interface and has a method to set the current-menuaction."
    },
    {
      "ansID": 1158,
      "ans": "these are the codes for my answer:\r\npublic interface IMenuAction\r\n    {\r\n        void Add();\r\n        void Remove();\r\n        //...\r\n    }\r\n    public class ManagerMenuAction : IMenuAction\r\n    {\r\n        #region IMenuAction ??\r\n        public void Add()\r\n        {\r\n            //Do something.\r\n        }\r\n        public void Remove()\r\n        {\r\n            //Do something.\r\n        }\r\n        #endregion\r\n    }\r\n    public class MenuActionController\r\n    {\r\n        Dictionary\u003cstring, IMenuAction\u003e container \u003d new Dictionary\u003cstring, IMenuAction\u003e();\r\n        IMenuAction _currentMenuAction;\r\n        public IMenuAction GetCurrentMenuAction\r\n        {\r\n            get\r\n            {\r\n                return _currentMenuAction;\r\n            }\r\n        }\r\n        public void AddMenuAction(string key, IMenuAction action)\r\n        {\r\n            if(!container.ContainsKey(key))\r\n                container.Add(key, action);\r\n        }\r\n        public void SetCurrentMenuAction(string key)\r\n        {\r\n            _currentMenuAction \u003d container[key];\r\n        }\r\n    }\r\n    public class Invoker\r\n    {\r\n        MenuActionController _controller \u003d new MenuActionController();\r\n        public void Run()\r\n        {\r\n            IMenuAction action \u003d new ManagerMenuAction();\r\n            _controller.AddMenuAction( \u0027Manager \u0027, IMenuAction);\r\n            //Add others\r\n            _controller.SetCurrentMenuAction( \u0027Manager \u0027);\r\n            //\r\n            _controller.GetCurrentMenuAction.Add();\r\n            _controller.GetCurrentMenuAction.Remove();\r\n            //...\r\n        }\r\n    }"
    }
  ]
}