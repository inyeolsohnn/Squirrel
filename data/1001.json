{
  "id": 1001,
  "url": "www.dofactory.com/topic/1001/singleton-as-a-static-class.aspx",
  "title": "Singleton as a static class",
  "ques": "I was wondering why are Singletons not implemented as a static class with a static public Instance property?",
  "answers": [
    {
      "ansID": 1000,
      "ans": "\r\nSingleton pattern ensure that there would be only one class instance available at any point in time but you can not create instance of a class( even a single instance) which is maked as a static.\r\n"
    },
    {
      "ansID": 1017,
      "ans": "I will talk only about one perspective as right now only this hit my mind ;)\r\n\r\nLet\u0027s say your singleton class is per context base. Take for an example your ShoppingCart class, and for it you need to have only one instance per customer session. Obviously a simple static class won\u0027t do here. Singleton is all about having the same  \u0027INSTANCE \u0027 throughout a particular context.\r\n\r\nAnd why will we like to do that. Well in this particular scenario we are doing it for state management as the same instance is entertaining different requests so we can have ShoppingCart data through out that session."
    },
    {
      "ansID": 1018,
      "ans": "The primary reason you wouldn\u0027t use a Singleton as a static class has to do with the potential for multi-threading issues. Note the following quote from http://msdn.microsoft.com/en-us/library/ms998558.aspx. If \r\n\r\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\r\nStatic Initialization \r\n\r\n\r\nOne of the reasons Design Patterns [Gamma95] avoided static initialization is because the C++ specification left some ambiguity around the initialization order of static variables. Fortunately, the .NET Framework resolves this ambiguity through its handling of variable initialization:\r\n\r\n\r\n\r\n\r\nCopy Code \r\n\r\n \r\n\r\npublic sealed class Singleton\r\n{\r\n   private static readonly Singleton instance \u003d new Singleton();\r\n   \r\n   private Singleton(){}\r\n\r\n   public static Singleton Instance\r\n   {\r\n      get \r\n      {\r\n         return instance; \r\n      }\r\n   }\r\n}\r\n \r\nIn this strategy, the instance is created the first time any member of the class is referenced. The common language runtime takes care of the variable initialization. The class is marked sealed to prevent derivation, which could add instances. For a discussion of the pros and cons of marking a class sealed, see [Sells03]. In addition, the variable is marked readonly, which means that it can be assigned only during static initialization (which is shown here) or in a class constructor. \r\nThis implementation is similar to the preceding example, except that it relies on the common language runtime to initialize the variable. It still addresses the two basic problems that the Singleton pattern is trying to solve: global access and instantiation control. The public static property provides a global access point to the instance. Also, because the constructor is private, the Singleton class cannot be instantiated outside of the class itself; therefore, the variable refers to the only instance that can exist in the system. \r\nBecause the Singleton instance is referenced by a private static member variable, the instantiation does not occur until the class is first referenced by a call to the Instance property. This solution therefore implements a form of the lazy instantiation property, as in the Design Patterns form of Singleton.\r\nThe only potential downside of this approach is that you have less control over the mechanics of the instantiation. In the Design Patterns form, you were able to use a nondefault constructor or perform other tasks before the instantiation. Because the .NET Framework performs the initialization in this solution, you do not have these options. In most cases, static initialization is the preferred approach for implementing a Singleton in .NET. \r\nMultithreaded Singleton \r\n\r\n\r\nStatic initialization is suitable for most situations. When your application must delay the instantiation, use a non-default constructor or perform other tasks before the instantiation, and work in a multithreaded environment, you need a different solution. Cases do exist, however, in which you cannot rely on the common language runtime to ensure thread safety, as in the Static Initialization example. In such cases, you must use specific language capabilities to ensure that only one instance of the object is created in the presence of multiple threads. One of the more common solutions is to use the Double-Check Locking [Lea99] idiom to keep separate threads from creating new instances of the singleton at the same time. \r\n\r\n\r\n\r\nNote: The common language runtime resolves issues related to using Double-Check Locking that are common in other environments. For more information about these issues, see  \u0027The \u0027Double-Checked Locking Is Broken\u0027 Declaration, \u0027 on the University of Maryland, Department of Computer Science Web site, at http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html.\r\nImplementing Singleton in C# results in the following benefits and liabilities:\r\nBenefits \r\n\r\n\r\nThe static initialization approach is possible because the .NET Framework explicitly defines how and when static variable initialization occurs. \r\n\r\nThe Double-Check Locking idiom described earlier in  \u0027Multithreaded Singleton \u0027 is implemented correctly in the common language runtime. \r\nLiabilities \r\n\r\n\r\nIf your multithreaded application requires explicit initialization, you have to take precautions to avoid threading issues."
    },
    {
      "ansID": 1026,
      "ans": "The Singleton pattern has several advantages over static classes. First, a singleton can extend classes and implement interfaces, while a static class cannot (it can extend classes, but it does not inherit their instance members). A singleton can be initialized lazily or asynchronously while a static class is generally initialized when it is first loaded, leading to potential class loader issues. However the most important advantage, though, is that singletons can be handled polymorphically without forcing their users to assume that there is only one instance"
    },
    {
      "ansID": 1754,
      "ans": "you can not create instance for static class, but singleton pattern maintains single instance\r\n\r\nhttp://www.dotnetquestionanswers.com/"
    }
  ]
}