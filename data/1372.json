{
  "id": 1372,
  "url": "www.dofactory.com/topic/1372/my-first-stab-at-the-factory-pattern.aspx",
  "title": "My first stab at the Factory Pattern. Feedback please.",
  "ques": "I am building a staffing tool and using the Factory Pattern. Can you please take a look and let me know if I did it right? Also, I\u0027m a bit confused about why I have to create a new creator class for each type. Can\u0027t I just make one method that returns the right employee type instead of making all of these creator classes?\r\n\r\n\r\n\r\n\r\n// abstract product\r\npublic abstract class Employee  \r\n{  \r\n   public abstract void Add();  \r\n   public abstract void Update();  \r\n   public abstract Employee Get();  \r\n   public abstract void Delete();  \r\n   public abstract DataTable Search();  \r\n   public string FirstName { get; set; }  \r\n   public string LastName { get; set; }  \r\n   public string Title { get; set; }  \r\n}  \r\n\r\n// concrete product 1\r\npublic class Developer : Employee  \r\n{  \r\n   public Developer()  \r\n   {  \r\n       Title \u003d \u0027Software Engineer\u0027;  \r\n   }  \r\n   public override void Add()  \r\n   {  \r\n   }  \r\n   public override void Update()  \r\n   {  \r\n   }  \r\n   public override Employee Get()  \r\n   {  \r\n       return new Model();  \r\n   }  \r\n   public override void Delete()  \r\n   {  \r\n   }  \r\n   public override DataTable Search()  \r\n   {  \r\n       throw new NotImplementedException();  \r\n   }  \r\n}  \r\n\r\n\r\n// concrete product 2\r\npublic class Secretary : Employee  \r\n{  \r\n   public Secretary()  \r\n   {  \r\n       Title \u003d \u0027Jr. Receptionist\u0027;  \r\n   }  \r\n   public override void Add()  \r\n   {  \r\n   }  \r\n\r\n   public override void Update()  \r\n   {  \r\n   }  \r\n\r\n   public override Employee Get()  \r\n   {  \r\n       return new Model();  \r\n   }  \r\n\r\n   public override void Delete()  \r\n   {  \r\n   }  \r\n\r\n   public override DataTable Search()  \r\n   {  \r\n       throw new NotImplementedException();  \r\n   }  \r\n}  \r\n\r\n// abstract creator\r\npublic abstract class EmployeeCreator  \r\n{  \r\n   // factory method\r\n   public abstract Employee CreateEmployee();  \r\n}  \r\n\r\n// concrete creator 1\r\npublic class DeveloperCreator : EmployeeCreator  \r\n{  \r\n   public override Employee CreateEmployee()  \r\n   {  \r\n       return new Developer();  \r\n   }  \r\n}  \r\n\r\n// concrete creator 2\r\npublic class SecretaryCreator : EmployeeCreator  \r\n{  \r\n   public override Employee CreateEmployee()  \r\n   {  \r\n       return new Secretary();  \r\n   }  \r\n}  \r\n\r\n// console app to test this all\r\nstatic void Main(string[] args)  \r\n{  \r\n    EmployeeCreator employeeCreator;  \r\n    if (args.Length \u003e 0)  \r\n    {  \r\n        EmployeeType type \u003d (EmployeeType)Enum.Parse(typeof(EmployeeType), args[0], true);  \r\n        if (type \u003d\u003d EmployeeType.Secretary)  \r\n        {  \r\n            employeeCreator \u003d new SecretaryCreator();  \r\n        }  \r\n        else\r\n        {  \r\n            employeeCreator \u003d new DeveloperCreator();  \r\n        }  \r\n    }  \r\n    else\r\n    {  \r\n        throw new InvalidOperationException();  \r\n    }  \r\n    Employee employee \u003d employeeCreator.CreateEmployee();  \r\n    Console.WriteLine(employee.Title);  \r\n    Console.ReadLine();  \r\n}  \r\n \r\n\r\n ",
  "answers": [
    {
      "ansID": 1528,
      "ans": "Basically you are making the subclasses to decide what to instantiate.\r\n\r\nIf you need to set specific behavoiur or properties to the instance that is created in the creater class, then this is useful. Also it lets good separation of concerns. \r\nFor instance, if  \u0027Secretary \u0027 timings are different based on the location, then those things can be set in the creater class.\r\nHope this helps you to understand...\r\n"
    },
    {
      "ansID": 1529,
      "ans": "Hi Joe,\r\n\r\n   You are pretty right.  In fact rather than creating so many  creator you can use the c# language feature generics and create one creator which accepts a generic type. Your code would be more maintainable.\r\n\r\n   For sample implementation do check the following links..\r\n\r\nhttp://aabs.wordpress.com/2007/11/21/a-generic-class-factory-for-c-30/\r\n\r\n\r\n  Short example here...(haven\u0027t tested this)\r\n\r\npublic class Program\r\n    {\r\n        // console app to test this all\r\n        static void Main(string[] args)\r\n        {\r\n            EmployeeType type;\r\n\r\n            if (args.Length \u003e 0)\r\n            {\r\n                type \u003d (EmployeeType)Enum.Parse(typeof(EmployeeType), args[0], true);\r\n            }\r\n            else\r\n            {\r\n                throw new InvalidOperationException();\r\n            }\r\n\r\n            Employee employee \u003d EmployeeFactory\u003cEmployee\u003e.Create(type);\r\n\r\n            Console.WriteLine(employee.Title);\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n\r\n    public static class EmployeeFactory\u003cT\u003e where T : Employee \r\n    {\r\n           public static T Create(EmployeeType type) \r\n           {\r\n               return (T)Activator.CreateInstance(Type.GetType( \u0027Test. \u0027 + type.ToString()));            \r\n           }\r\n    }\r\n  NOTE:; This is a quick and dirty code.  In CreateInstance I have hardcoded the  \u0027namespace \u0027.  You may need to modify the code to remove this hardcoding.  \r\n\r\nThis code uses reflection.  Though reflection is costly but it depends of the nature of app you are building.  In most cases I found the benefit overriding the cost.\r\n\r\nLet me know your thoughts.  \r\n\r\n\r\n\r\n Hope this helps.\r\n\r\n\r\n\r\n"
    },
    {
      "ansID": 1533,
      "ans": "Thanks, Rajesh. I made my actual implementation skip the generics and reflection. I\u0027m not really sure if I would need them. If you find any fault with that statement, please let me know how I could benefit from using them instead of this method below. I put this method into my abstract employee class, fyi.\r\n\r\n\r\n\r\n\r\npublic static Employee EmployeeFactory(EmployeeType type)\r\n{\r\n             if (type \u003d\u003d EmployeeType.Developer)\r\n                return new Developer();\r\n            else if (type \u003d\u003d EmployeeType.Secretary)\r\n                return new Secretary();\r\n\r\n}\r\n\r\n "
    },
    {
      "ansID": 1535,
      "ans": "I kinda like Rajesh version using generics. Here is another version of it (with generics)... what do you think?\r\n\r\n\r\nnamespace AbstractFactoryGenerics {\r\n    using System;\r\n    using System.Data;\r\n\r\n    internal class Program {\r\n        private static void Main() {\r\n            var developer \u003d EmployeeFactory.Create\u003cDeveloper\u003e();\r\n            var secretary \u003d EmployeeFactory.Create\u003cSecretary\u003e();\r\n\r\n            Console.WriteLine(string.Format( \u0027I\u0027m a {0} \u0027, developer));\r\n            Console.WriteLine(string.Format( \u0027I\u0027m a {0} \u0027, secretary));\r\n        }\r\n\r\n        public class Developer : Employee {\r\n            public Developer() {\r\n                Title \u003d  \u0027Software Engineer \u0027;\r\n            }\r\n\r\n            public override void Add() {}\r\n            public override void Update() {}\r\n            public override Employee Get() {\r\n                throw new NotImplementedException();\r\n            }\r\n            public override void Delete() {}\r\n            public override DataTable Search() {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public override string ToString() {\r\n                return Title;\r\n            }\r\n        }\r\n\r\n        public abstract class Employee {\r\n            public string FirstName { get; set; }\r\n            public string LastName { get; set; }\r\n            public string Title { get; set; }\r\n            public abstract void Add();\r\n            public abstract void Update();\r\n            public abstract Employee Get();\r\n            public abstract void Delete();\r\n            public abstract DataTable Search();\r\n        }\r\n\r\n        public class Secretary : Employee\r\n        {\r\n            public Secretary()\r\n            {\r\n                Title \u003d  \u0027Jr. Receptionist \u0027;\r\n            }\r\n            public override void Add() { }\r\n\r\n            public override void Update() { }\r\n\r\n            public override Employee Get()\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public override void Delete() { }\r\n\r\n            public override DataTable Search()\r\n            {\r\n                throw new NotImplementedException();\r\n            }\r\n\r\n            public override string ToString()\r\n            {\r\n                return Title;\r\n            }\r\n        }\r\n\r\n        public static class EmployeeFactory {\r\n            public static T Create \u003cT\u003e() {\r\n                return (T) Activator.CreateInstance(typeof(T));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n "
    },
    {
      "ansID": 1541,
      "ans": "Hi Joe,\r\n\r\nI would prefer a single class called EmployeeCreatorFactory exposing a set of methods one for each employee type. Something like the following pseudo code:\r\n\r\npublic class EmployeeCreatorFactory\r\n{\r\n        public Employee createSecretary()\r\n        {\r\n        }\r\n\r\n        public Employee createDeveloper()\r\n        {\r\n        }\r\n\r\n        public Employee createContingentWorker()\r\n        {\r\n        }\r\n}\r\n\r\nThanks."
    }
  ]
}