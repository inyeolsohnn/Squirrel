{
  "id": 1378,
  "url": "www.dofactory.com/topic/1378/abstract-factory-how-to-break-down-a-large-factory.aspx",
  "title": "Abstract Factory - How to break down a large factory?",
  "ques": "In the Patterns in Action solution of the Design Pattern Framework (v3.5) the data access layer uses the Abstrat Factory pattern to shield creation of data access objects from the client.  With a small number of data access objects this seems to be OK, however when modelling a database with hundreds of tables, the number of data access objects quickly grows and in turn results in large factories which each have to be updated when a table/data access object is added.\r\n\r\n Is there a way to break down a large factory in some way to make it more maintainable and to adhere to the open closed principle?\r\n\r\n One possible idea I can think of is to have a generic method as follows (where T would be a DAO Interface):\r\n\r\n public T CreateInstance\u003cT\u003e()\r\n {\r\n     // Use reflection here to lookup a concrete type in the DataAccess assembly that implements T\r\n }\r\n\r\n then the business logic classes would have a private instance e.g.:\r\n\r\n private static ICustomersDao _customerDao \u003d DataAccess.CreateInstance\u003cICustomersDao\u003e();\r\n\r\n\r\n I think each DAO interface would need to inherit from a marker interface so that a generic constraint could be placed on the method to limit the types that could be returned.\r\n\r\n Assuming the data access layer supports SQL, Oracle, etc, then the CreateInstance\u003cT\u003e() method would have to only lookup concreate classes in the relevant namespace, so if the DB provider was set to \u0027System.Data.SqlClient\u0027 in the config then we would only want to find a concrete class in the SqlServer DAO namespace.\r\n\r\n Would this work?  Any other suggestions?\r\n",
  "answers": [
    {
      "ansID": 1540,
      "ans": "Generics approach will work.  I have implemented my own custom DAL 5 years back and it is still going smooth (no exaggeration here).\r\n\r\nThe approach is similar to what is in EF , but with a twist.  Just to outline how it works (there are no class clutters)..\r\n\r\nAssume there is a Customer table in the DB.  The entity is modelled as below\r\n\r\n[Table ( \u0027ebCustomerMaster \u0027)]\r\npublic class Customer\r\n{\r\n    [Column()]\r\n     public Guid Id {\r\n             get { return id; }\r\n             set { id \u003d value; }\r\n     }\r\n\r\n    [Column()]\r\n     public string Name{\r\n             get { return name; }\r\n             set { name \u003d value; }\r\n     }\r\n}\r\n\r\nI am just displaying a subset of properties.  Note this class is auto generated by a custom utility.\r\n\r\nNow we have a SmartData\u003cT\u003e class which is responsible for generating the SQL based on xml file (as this was our requirement).\r\n\r\nA sample insert function in the SmartData is displayed below.\r\n\r\n\r\n    public class SmartData\u003cT\u003e\r\n    {\r\n\r\n        public int Insert(T obj, string spName)\r\n        {\r\n            DataRow queryRow \u003d dsSQL.Tables[ \u0027Query \u0027].Select( \u0027Id \u003d \u0027 \u0027 + spName +  \u0027\u0027 \u0027)[0];\r\n\r\n            string commandText \u003d queryRow[ \u0027CommandText \u0027].ToString();\r\n            string commandType \u003d queryRow[ \u0027CommandType \u0027].ToString();\r\n\r\n            Request request \u003d new Request();\r\n            request.CommandText \u003d commandText;\r\n\r\n            request.CommandType \u003d (CommandType)Enum.Parse(typeof(CommandType), commandType);\r\n            ProcessParameter(obj, request);\r\n\r\n            return dbEngine.Insert(request);\r\n        }\r\n        \r\n         // MORE functions goes here....\r\n        \r\n}\r\n\r\nNOTE : Here there is no scope for SQL injection attach as the actual sql is not built here....\r\n\r\nThen there\u0027s a DB engine which is responsible for talking with the underlying dtabase.\r\n\r\nThe DBEngine\u0027s Insert function is shown below...\r\n\r\n        public int Insert(Request request)\r\n        {\r\n            using (DbCommand command \u003d factory.CreateCommand())\r\n            {\r\n                int ret \u003d 0;\r\n                //if (null \u003d\u003d connection || connection.State !\u003d ConnectionState.Open)\r\n                OpenConnection();\r\n\r\n                command.Connection \u003d connection;\r\n                if (request.Parameters.Count \u003e 0)\r\n                {\r\n                    foreach (Parameter para in request.Parameters)\r\n                    {\r\n                        DbParameter p1;\r\n                        switch (dataProvider)\r\n                        {\r\n                            case  \u0027System.Data.OleDb \u0027:\r\n                                p1 \u003d new System.Data.OleDb.OleDbParameter(para.ParameterName, para.Value);\r\n                                p1.DbType \u003d GetDbTypeFromString(para.DataType);\r\n                                command.Parameters.Add(p1);\r\n                                break;\r\n                            case  \u0027System.Data.SqlClient \u0027:\r\n                                p1 \u003d new System.Data.SqlClient.SqlParameter(para.ParameterName, para.Value);\r\n                                p1.DbType \u003d GetDbTypeFromString(para.DataType);\r\n                                command.Parameters.Add(p1);\r\n                                break;\r\n                            default:\r\n                                command.Parameters.Add(para);\r\n                                break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                command.CommandText \u003d request.CommandText;\r\n                command.CommandType \u003d request.CommandType;\r\n                command.CommandTimeout \u003d 0;\r\n\r\n                ret \u003d command.ExecuteNonQuery();\r\n            \r\n                return ret;\r\n            }\r\n\r\nThe actual code may differ than what is shown here....\r\n\r\nThe good thing is there are no sub classes or any other helpers apart from the usual Service layer....\r\nThe DBEngine abstracts away the providers.  The query details in the XML gives us the flexibility to switch to stored procedures\r\nor plain SQL queries at will.\r\n\r\nSwitching providers is as easy as creating a new xml file and updating only specifics which changes (in most cases\r\nsql server, mysql, and oracle, most of the things are same)......\r\n\r\n\r\nNOTE and suggestion:  I had taken this approach when EF was not available (or was in early stages) and data access  block \r\nwas also in  a very early stage.\r\n\r\nI will recommend you also have a look at the MS Enterprise Library Data access blocks as well.  But don\u0027t be afraid to roll out your own if need arises.\r\n\r\nThis custom solution has provided me with a lot of flexibility in  a real enterprise application handling about 400 tables of data entry and about 1000 reports.... So, you can imagine the magnitude of usage of this library.. The only thing is it is not opensource, but there are various similar implementations available, and if you need to roll out, you can quickly do so... It\u0027s not that complex.\r\n\r\nHope this helps !\r\n\r\n\r\n\r\n"
    }
  ]
}