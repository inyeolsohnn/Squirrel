{
  "id": 1495,
  "url": "www.dofactory.com/topic/1495/asynchronous-soa-calls.aspx",
  "title": "Asynchronous SOA calls",
  "ques": "I\u0027m enjoying studying your Patterns In Architecture framework.  Currently, I am particularly interested in setting up asynchronous communication over a SOA interface.  We are building a GUI with many desktops, each containing many windows, each of which can show views of data retrieved from a decoded message-file.  Each window shall retrieve its data seperately over a SOA interface, which hopefully will end up being small and usable like your IActionService interface.  In our very data-intensive system, no request for data may block as this would make the GUI unresponsive.\r\n\r\nIn your framework you use the Request-Response SOA messaging pattern, it works perfectly and is easy to understand.\r\nWould you care to advise as to how your IActionService interface might look if you needed to make your calls asynchronous?\r\n\r\nvar response \u003d Client.GetCustomers(request);\r\nare the type of calls that I\u0027m referring to.\r\n\r\nAlso: do you recommend the book SOA Design Patterns by Thomas Erl, or can you recommend any other good books that would provide up-to-date advice?\r\n\r\nRegards,\r\nMark\r\n",
  "answers": [
    {
      "ansID": 1684,
      "ans": "Below is some code that shows a rudimentary solution. It works in a console application, for a true UI you will need do do more, e.g. marshal the callback event to the UI thread.\r\n\r\nThe attached  \u0027SoaAsync.zip \u0027 file also contains a quick WPF application.\r\n\r\n\r\nclass ClientArgs : EventArgs\r\n    {\r\n        public Reply Reply { get; set; }\r\n    }\r\n\r\n    class Request\r\n    {\r\n        public string Input;\r\n    }\r\n\r\n    class Reply\r\n    {\r\n        public string Output;\r\n    }\r\n\r\n    class Client\r\n    {\r\n        public delegate void CallCompletedDel(object sender, ClientArgs args);\r\n\r\n        public event CallCompletedDel CallCompletedEvent;\r\n\r\n        public void RequestAsync(Request req)\r\n        {\r\n            if( null !\u003d CallCompletedEvent)\r\n            {\r\n                ClientArgs args \u003d new ClientArgs();\r\n                args.Reply \u003d new Reply();\r\n                args.Reply.Output \u003d req.Input +  \u0027 Output \u0027;\r\n\r\n                // this will actually go to the Web Services as an async call\r\n                CallCompletedEvent.BeginInvoke(this, args, null, null);  \r\n            }\r\n        }\r\n    }\r\n\r\nthen you uses it in the following way\r\n\r\n            ManualResetEvent block \u003d new ManualResetEvent(false);\r\n            bool _isAsyncDone \u003d false;\r\n            Reply reply \u003d null;\r\n            int _timeout \u003d 1000;\r\n\r\n            Client client \u003d new Client();\r\n            \r\n            client.CallCompletedEvent +\u003d (sender, e) \u003d\u003e\r\n            {\r\n                if( null !\u003d e)\r\n                {\r\n                    reply \u003d e.Reply;\r\n                    _isAsyncDone \u003d true; \r\n                    block.Set(); \r\n                }\r\n            };\r\n\r\n\r\n            Request req \u003d new Request();\r\n            req.Input \u003d  \u0027Input \u0027;\r\n            client.RequestAsync(req);\r\n\r\n            block.WaitOne(_timeout, false);\r\n\r\n            if (false \u003d\u003d _isAsyncDone)\r\n            {\r\n                Console.WriteLine( \u0027Test took too long \u0027);\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(reply !\u003d null ? reply.Output :  \u0027Reply is null \u0027);\r\n            }\r\n\r\n "
    }
  ]
}