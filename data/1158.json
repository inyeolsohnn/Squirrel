{
  "id": 1158,
  "url": "www.dofactory.com/topic/1158/replace-conditional-vb-net-select-case-with-strategy-pattern-how.aspx",
  "title": "Replace conditional (VB.NET: Select-Case) with Strategy Pattern... HOW?!",
  "ques": "Alright folks,... let\u0027s get to the point: Buzz words sometimes help to understand that there is something that needs to be improved. What might be even more helpful is a hint on HOW to actually improve something.\r\n\r\nLike this one.\r\n\r\nAnyone knows that a good developer follows the open-closed principle. Open to extension, closed to change. Select-Case in VB.NET for instance discounts this.\r\n\r\nIf you have something like:\r\nSelect Case customer.Type\r\n  Case CustomerType.GoodCustomer\r\n    ...\r\n  Case CustomerType.BadCustomer\r\n    ....\r\n  Case Else\r\n    .....\r\nEnd Select\r\n\r\nYou will end up in having to change your existing implementation each time a new type of customer arises. The strategy pattern can help in implementing something to avoid this potential risk.\r\n\r\nI took the example on this website: http://blogs.microsoft.co.il/blogs/gilf/archive/2009/11/22/applying-strategy-pattern-instead-of-using-switch-statements.aspx\r\n\r\nIt works pretty well. However,... now I need to change the implementation of the Context class to add new types to an internal Dictionary. Also it doesn\u0027t handle the Case Else.\r\n\r\nCan anyone please introduce an example of how to apply the Strategy Pattern in a way that allows me to replace Conditionals with a construct that renders changes in existing code completely unnecessary and even handles Case Else?\r\n\r\nThat\u0027d be awesome!",
  "answers": [
    {
      "ansID": 1235,
      "ans": "Hi,\r\n\r\n   This is interesting... I have taken a somewhat different approach to the\r\n   strategy pattern than what is presented on that page. First I have removed\r\n   the need for enums, as I try to avoid them if possible for maintainability concerns.\r\n\r\n   The context is now a full blown object using no statics.\r\n\r\n   The default behavior is initialized in the constructor, this should be equivalent\r\n   with the \u0027case else\u0027.\r\n\r\n   To change the behavior of the context you provide a new IPassengerTitleStrategy\r\n   for the constructor. In this implementation it isn\u0027t possible to change behavior\r\n   after the object was created but that is easily fixed by adding a property to\r\n   the class.\r\n\r\n   Also, if you need new behavior just add another class that inherits from the\r\n   IPassengerTitleStrategy, there is no need to modify any enums or the Context\r\n   class at all.\r\n\r\n   Let me now if I completely missed the intent of you question :o) \r\n\r\n\r\n\r\nusing System; \r\n\r\nnamespace StrategyPattern \r\n{ \r\n    public class Program \r\n    { \r\n        private static void Main(string[] args) \r\n        { \r\n            var context \u003d new Context(); \r\n            context.DoAlgorithm(); \r\n\r\n            context \u003d new Context(new MrPassengerTitleStrategy()); \r\n            context.DoAlgorithm(); \r\n        } \r\n\r\n        #region Nested type: Context \r\n\r\n        public class Context \r\n        { \r\n            private readonly IPassengerTitleStrategy _passengerTitleStrategy; \r\n\r\n            public Context() \r\n            { \r\n                _passengerTitleStrategy \u003d new RudePassengerTitleStrategy(); \r\n            } \r\n\r\n            public Context(IPassengerTitleStrategy passengerTitleStrategy) \r\n            { \r\n                _passengerTitleStrategy \u003d passengerTitleStrategy; \r\n            } \r\n\r\n            public void DoAlgorithm() \r\n            { \r\n                _passengerTitleStrategy.DoAlgorithm(); \r\n            } \r\n        } \r\n\r\n        #endregion\r\n\r\n        #region Nested type: DoctorPassengerTitleStrategy \r\n\r\n        public class DoctorPassengerTitleStrategy : IPassengerTitleStrategy \r\n        { \r\n            #region IPassengerTitleStrategy Members \r\n\r\n            public void DoAlgorithm() \r\n            { \r\n                Console.WriteLine( \u0027Dr. \u0027); \r\n            } \r\n\r\n            #endregion\r\n        } \r\n\r\n        #endregion\r\n\r\n        #region Nested type: IPassengerTitleStrategy \r\n\r\n        public interface IPassengerTitleStrategy \r\n        { \r\n            void DoAlgorithm(); \r\n        } \r\n\r\n        #endregion\r\n\r\n        #region Nested type: MrPassengerTitleStrategy \r\n\r\n        public class MrPassengerTitleStrategy : IPassengerTitleStrategy \r\n        { \r\n            #region IPassengerTitleStrategy Members \r\n\r\n            public void DoAlgorithm() \r\n            { \r\n                Console.WriteLine( \u0027Mr. \u0027); \r\n            } \r\n\r\n            #endregion\r\n        } \r\n\r\n        #endregion\r\n\r\n        #region Nested type: MrsPassengerTitleStrategy \r\n\r\n        public class MrsPassengerTitleStrategy : IPassengerTitleStrategy \r\n        { \r\n            #region IPassengerTitleStrategy Members \r\n\r\n            public void DoAlgorithm() \r\n            { \r\n                Console.WriteLine( \u0027Mrs. \u0027); \r\n            } \r\n\r\n            #endregion\r\n        } \r\n\r\n        #endregion\r\n\r\n        #region Nested type: RudePassengerTitleStrategy \r\n\r\n        public class RudePassengerTitleStrategy : IPassengerTitleStrategy \r\n        { \r\n            #region IPassengerTitleStrategy Members \r\n\r\n            public void DoAlgorithm() \r\n            { \r\n                Console.WriteLine( \u0027#?%\u0026! \u0027); \r\n            } \r\n\r\n            #endregion\r\n        } \r\n\r\n        #endregion\r\n    } \r\n} \r\n\r\n "
    },
    {
      "ansID": 1240,
      "ans": "This post is a continuation from the previous one, which shows how to get all classes that implements the IPassengerTitleStrategy and create and object of them and put them in a list which could be used to databind to a drop down list.\r\n\r\nThe following method will populate an IList whith implementations of type T.\r\n\r\nprivate static IList\u003cT\u003e GetObjectsFrom\u003cT\u003e() {  \r\n    Type strategyType \u003d typeof (T);  \r\n    List\u003cType\u003e types \u003d AppDomain.CurrentDomain.GetAssemblies()\r\n                      .SelectMany(s \u003d\u003e s.GetTypes())\r\n                      .Where(p \u003d\u003e strategyType.IsAssignableFrom(p) \u0026\u0026 p.IsClass).ToList();  \r\n    return types.Select(type \u003d\u003e (T) Activator.CreateInstance(type)).ToList();  \r\n}  \r\nThis is how you can retrieve a list of objects from the classes that implements the interface IPassengerTitleStrategy:\r\n\r\nprivate static void Main(string[] args) { \r\n\r\n  var types \u003d GetObjectsFrom\u003cIPassengerTitleStrategy\u003e();  \r\n  foreach (var passengerTitleStrategy in types) {  \r\n    new Context(passengerTitleStrategy).DoAlgorithm();  \r\n  }  \r\n}\r\n\r\n "
    }
  ]
}