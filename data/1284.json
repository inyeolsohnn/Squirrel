{
  "id": 1284,
  "url": "www.dofactory.com/topic/1284/abstract-factory-vs-factory-method.aspx",
  "title": "Abstract Factory vs Factory Method",
  "ques": "I believe I have a good understanding of the difference between Abstract Factory and Factory Method, but I\u0027d like to see what others think.\r\nWhen I say Abstract I am referring to DoFactory.GangOfFour.Abstract.Structural - Abstract Factory\r\nWhen I say Factory I am referring to DoFactory.GangOfFour.Factory.Structural - Factory Method\r\nFirst, both of these patters are are very close siblings of each other, more like faternal twins.  From what I see, Abstract can almost always be used in place of Factory.  Abstract typically implements Factory.  The difference is basically another level of abstraction at the Client end - Abstract implements this additional level of abstraction.\r\nThe Client in Abstract is AnimalWorld.  The Client in Factory is simply MainApp.\r\nFrom within both of these Clients, the factory is implemented in these lines:\r\nFactory:\r\ndocuments[0] \u003d new Resume();\r\ndocuments[1] \u003d new Report();\r\nAbstract:\r\n _carnivore \u003d factory.CreateCarnivore();\r\n_herbivore \u003d factory.CreateHerbivore();\r\nThe difference here is that in Factory, the Client (Main) is hard coded with the objects it will create.\r\nIn Abstract, the Client (AnimalWorld) is passed in the factory used to create the objects.\r\nSimply another level of inderection implemented in Abstract.\r\nThis additional level of inderection will allow for the ability to change the types of objects that the Client uses without recompiling the code.  To state it another way:\r\nFactory allows for the Client to use objects that dynamically create themselves - Resume and Report generate their own members.\r\nAbstract allows for the Client to be passed in a dynamically created object that will then dynamically create additional objects for the Client.\r\nAll of this sounds very academic and the naming is very confusing.  I would have named the patterns as such:\r\nFactory \u003d Factory Method (GoF) \u003d Factory Method (Mike)\r\nAbstract \u003d Abstract Factory (GoF) \u003d Abstract Factory Method (Mike)\r\nThis would imply that Abstract Factory Method is simply an implementation of Factory Method, with an additional level of inderection - which is the real world case.\r\nThis reminds me of a quote I read a while back - \u0027There is no problem in OOP that can not be solved through another level of inderection, except of course, too much inderection\u0027.\r\nSpeaking of real world, where would I decide to use one or the other?  I\u0027ll first point out the limitation of the Factory.  The lines:\r\ndocuments[0] \u003d new Resume();\r\ndocuments[1] \u003d new Report();\r\n\r\ncreate the Resume and Report - those classes then create the proper Pages.  I see Resume and Report as the Factories.\r\nLets say the team that developes Resume and Report comes up with version 2.  In the Factory method the Client (Main) code would have to be updated and recompiled:\r\ndocuments[0] \u003d new Resume2();\r\ndocuments[1] \u003d new Report2();\r\nThis is a requirment of the OCP - we cant just update Resume and Report to handle version 2.\r\nNow lets look at Abstract.  Here the client is AnimalWorld. \r\nContinentFactory africa \u003d new AfricaFactory();\r\nAnimalWorld world \u003d new AnimalWorld(africa);\r\nworld.RunFoodChain();\r\nIt is clear here what the factory is and that it is being passed to AnimalWorld (the Client).\r\nLets say the team that is developing Africa comes up with version 2.  The code is then cahnged to the following:\r\nContinentFactory africa \u003d new AfricaFactory2();\r\nAnimalWorld world \u003d new AnimalWorld(africa);\r\nworld.RunFoodChain();\r\n\r\nThis keeps us from recompiling the Client (AnimalWorld).  Big deal, right?  We still have to recompile Main, so what\u0027s the difference?\r\nIf you look in the Object Orientedd Analysis and Design with Applicaiton book (chapter 3 - Case Study Weather Station) they overcome the requirement to recompile Main by passing in to Main on the command line the TypeOf Factory.  This allows them to dynamically generate either AfricaFactory() or AfricaFactory2() - so no recompile is necessary at all.  They use weather station stuff, I\u0027m putting it into context by saying AfricaFactory......\r\nHonestly, it almost seems they had to justify the reasons for Abstract Factory by coming up with this cool implementation of passing in on the commandline the factory to instantiate.  And as they point out, this was a very new feature of Java anyway.  There is a much better reason for using Abstract.\r\nSo where does Abstract come into play by todays standards?  In Unit Testing.  The reason in my opinion to use Abstract (almost always) is so that the Client can be passed in different Factories - either the live Production Factory, or a stub/mock from a unit testing framework.\r\nAfter thinking about this a bit more, I realize that by using Factory + Dependency Injection (such as Ninject or Unity) you are accomplishing Abstract.  So if you spent hours looking at Factory and Abstract wondering what is the difference and where would you implement one or the other, stop - just get back to writing code, you are probably using these patterns already anyway.\r\nI think DoFactory has done a great job with providing this framework and I highly recommend it.  I would however recommend that the framework first presents the user Factory, then Abstract.  Because the projects are simply orderd alphabetically, the user first learns Abstract then gets to Factory and (in my case) wonders what the real difference is.  \r\nMike",
  "answers": [
    {
      "ansID": 1392,
      "ans": "Nice thinking Mike."
    }
  ]
}