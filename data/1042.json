{
  "id": 1042,
  "url": "www.dofactory.com/topic/1042/the-ideal-pattern.aspx",
  "title": "The ideal pattern",
  "ques": "In a software that I\u0027m developing, I\u0027ve a problem, I\u0027m searching a solution for that, and I think that a solution can come from a design pattern, so I\u0027m here for some suggestions.\r\n The software must connect to a server, the server can be of a different type (for example FTP and SQL), after the connection the software must perform some actions, for example download a list of something.\r\n We have different type of server, so if the software is connected on a FTP server, the action is download a list of files, if the software is connected on a SQL server the action is a query on a table.\r\n When the software starts, it loads a configuration file, on this file there are some server informations, what happen in reality is a population of a list of ServerInfo objects, each object contains the server type, the address and the login data.\r\n I\u0027m searching an elegant and transparent solution, I don\u0027t want code like this:\r\n\r\nServer server; \r\n\r\nif (serverInfo.type \u003d\u003d FTP) \r\n    server \u003d new FTPServer(); \r\nelse if (serverInfo.type \u003d\u003d SQL) \r\n    server \u003d new SQLServer(); \r\n\r\nserver.connect(); \r\nStudying the problem I\u0027ve found a possible solution with the Abstract Factory pattern, but I\u0027m really new to the world of desing patterns, so I\u0027m not sure if this is the correct solution, and I don\u0027t understand very well how to model my problem on this pattern.\r\nThanks.",
  "answers": [
    {
      "ansID": 1065,
      "ans": "Abstract Factory Pattern is concerned about creating families of related/dependent object. As the requirement is, based on the configuration application will connect to different server. After that you will be retrieving data from the server.\r\nSo you are not really looking for the object that are getting created or you are not concerned about the object returned. Only the need to get the collection that is having strings.\r\nThere are two algorithms, connect to FTP/SQL Server and get the data. These are two different behaviors and Data. So what we need to do is implement these algorithms in to two different classes and provide an encapsulation in one classes and make them interchangeable based on the configuration. So we will need to implement Strategy pattern here. Even if in feature we can also hook-up with the new server.\r\nI don?t see any scope for the Abstract Factory Pattern here, until unless we are developing complete custom framework for data access layer. If you had developed one, it will on the Abstract Factory.\r\nAny suggestions, always welcome\r\nThanks,\r\nChinna Srihari\r\n"
    },
    {
      "ansID": 1069,
      "ans": "I don\u0027t understand if that\u0027s the correct/right pattern for my problem, but sure, I\u0027m here for learn.\r\n\r\nAfter the application starts, and after the server selection has taken place, the app is always connected to the server. The user can perform different operations, for example, add data (a file or directory if we are connected to an FTP server) or add a value to a table (if we are connected to a SQL server).\r\n\r\nPlus, I need a global access to the server class, like a Singleton, because it will be accessed by serveral classes throughout my application. \r\n\r\nYou presented a nice solution and the Strategy Pattern looks very interesting.  \r\nSo, am I right to think that I will need a Singleton \u0027wrapper\u0027 class?\r\n\r\nThanks."
    },
    {
      "ansID": 1070,
      "ans": "Yes, I do agree, with the requirements that when any one connects to server we must be able to perform operations like \r\n\r\n\r\nOn FTP: Add file, Delete file, Edit file, Add folder etc...\r\nOn SQL Server: CRUD operations (Create, Read, Update, Delete)What we need to do is that, by looking at the requirements, in Abstract Factory we will have an abstract class which is like a template class where all concrete classes will implement the same. Here we don?t have any as such common functionality. That is where I was looking at.\r\nBut what we can also do here is that, for each Server we can have one Abstract Factory written. But it will be huge efforts for us J\r\n\r\n"
    },
    {
      "ansID": 1071,
      "ans": "Sorry but I\u0027m very new in this world (Design Patterns), and now I\u0027m very confused :-(!\r\nI don\u0027t understand if the solution is Strategy Pattern or Abstract Factory Pattern."
    },
    {
      "ansID": 1072,
      "ans": "I don\u0027t think you need Abstract Factory. You just need to implement Factory Method pattern.\r\n\r\nIt will effectively make your client code unaware of the actual type and let it deal with the abstraction (your Server class).\r\n\r\n\r\n\r\nclass ServerFactory\r\n{ \r\n   public Server GetServerInstance(string serverType)\r\n   {\r\n      //here you will put that code of yours that you have given above\r\n   }\r\n}\r\nAnother implementation I have discussed in a reply to a message in my article can be viewed at\r\n\r\nhttp://www.codeproject.com/KB/recipes/strategyPatternPrimerC.aspx\r\n\r\nI could copy paste the code, but then it wouldn\u0027t make the context clear.  Check my reply to supercat9\u0027s message.\r\n\r\nHopefully this will solve your problem.\r\n\r\nIn all your code you will do something like this\r\n\r\n\r\n  \r\n  ServerFactory factory \u003d new ServerFactory();\r\n  Server server \u003d factory.GetServerInstance( \u0027ftpServer \u0027);\r\n\r\nOf course you can use enums instead of strings, but the other implementation I discussed, is extendible, and enums won\u0027t do.\r\n\r\nBut keep in mind, that if your base behavior is covering almost every need, only then this pattern will help you best, otherwise i doubt it\u0027s applicability. What I mean to say is that if you\u0027re using Factory to create instances, and then just a few lines below you\u0027re casting it to concrete type, then I am afraid you\u0027re on a wrong path\r\n "
    },
    {
      "ansID": 1074,
      "ans": "Sorry i just read the complete post, so I have to update.\r\n I don\u0027t see much room for a generic base behavior in your case. Let\u0027s take an example of getting Data.\r\n\r\n server.GetData(string uriOrFilePathOrQueryStringEtcEtc) but what will it return. Let\u0027s say you choose XML, so it will be able to cover hierarchical nature of your ftp directory structure, as well as the result of a query from Sql Server. Ok case handled.\r\n\r\n What about renaming a file. Renaming a file is totally different from updating a record. parameters are totally different from each other. Ftp will include other operations like server.MakeDirectory, server.UploadFile\r\n\r\n To make all these servers adhere to a standard interface, we may end up writing a very very tricky code, I think what you were thinking of was something like this\r\n\r\n   interface IServer\r\n    {\r\n      GetData()\r\n     UpdateData()\r\n     ........................................\r\n    }\r\n and then make up you concrete servers on this basis. and then implementing your concrete servers like \r\n SqlServer\r\n {\r\n   GetData()\r\n    UpdateData()\r\n-------------\r\n }\r\n\r\n The problem I see is too much different parameters, and disagreement on a base interface, which rules out the application of factory method.  Now as far as Strategy is concerned, I see the same problem.\r\n\r\n"
    },
    {
      "ansID": 1083,
      "ans": "The right design pattern to apply depends really on the following:\r\n\r\n\r\nDo you really have a family of components that need to play with each other? \r\nHow much commonality do you have between the variation points, e.g., FTP and SQL servers?\r\nIs a design pattern really need it? Is it a one-time throw-away code or a long term product that needs to be designed with extensibility in mind? Since I don\u0027t have much information about your project, I\u0027ll throw a few scenarios.\r\n\r\n\r\nIf your design is a single-entry point, i.e., one-class component which then knows how to instaniate other classes, then the most seamless way is to store the full class name in a config file, then at run time, read that class name string from the config file and dynamically instantiate it. No \u0027ifs\u0027 or \u0027conditionals\u0027 there. \r\nOn the other hand, if you have many components that need to interact with each other at run time, you can implement an Abstract Factory to create the consistent family of components per server type or variation point. For example, if it is \u0027FTP\u0027 in the config, then the factory would create an FTPApp, FTPGui and FTPGateway etc... if it\u0027s \u0027SQL\u0027 then the factory would instantiate a SQLApp, SQLGui, SQLGateway etc... all consistent family. In this case, your interface would be coarse-grained and would only include high level methods such as Initialize(), Connect() and Close() and each concrete class would implement the details. They\u0027ll play nicely together because they\u0027re all from the same family.\r\nIf both the above options are not to your liking then implement a Simple Factory where it simply reads which server class to instaniate from the config file and instantiates that. Not much in common there. I hope that helps.\r\n\r\n-saleh"
    }
  ]
}